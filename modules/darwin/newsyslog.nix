{ config, lib, ... }:
let
  cfg = config.my.services.newsyslog;

  mkFlagString =
    flags:
    let
      result = lib.concatStrings (lib.sort lib.lessThan flags);
    in
    if result == "" then "-" else result;

  mkEntryLine =
    name: entry:
    let
      logfile = if entry.logfile != null then entry.logfile else name;
      ownerGroup =
        if entry.owner != null || entry.group != null then
          "${lib.optionalString (entry.owner != null) entry.owner}:${
            lib.optionalString (entry.group != null) entry.group
          }"
        else
          "";
      sizeStr = if entry.size == "*" then "*" else toString entry.size;
      flagStr = mkFlagString entry.flags;
      pidPart = lib.optionalString (entry.pidFile != null) "\t${entry.pidFile}";
      signalPart = lib.optionalString (entry.signal != null) "\t${toString entry.signal}";
    in
    "${logfile}\t${ownerGroup}\t${entry.mode}\t${toString entry.count}\t${sizeStr}\t${entry.when}\t${flagStr}${pidPart}${signalPart}";

  enabledEntries = lib.filterAttrs (_: entry: entry.enable) cfg.settings;
  configLines = lib.mapAttrsToList mkEntryLine enabledEntries;
  configText = ''
    # Generated by nix-darwin
    # Note: macOS runs newsyslog periodically via com.apple.newsyslog launchd job
    # logfilename          [owner:group]    mode count size  when  flags [/pid_file] [sig_num]
    ${lib.concatStringsSep "\n" configLines}
  '';

  flagsType = lib.types.listOf (
    lib.types.enum [
      "B"
      "C"
      "D"
      "G"
      "J"
      "N"
      "Z"
    ]
  );

  entryModule = lib.types.submodule (
    { name, ... }:
    {
      options = {
        enable = lib.mkEnableOption "this newsyslog entry" // {
          default = true;
        };
        logfile = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Log file path. Defaults to attribute name.";
          example = "/var/log/myapp.log";
        };
        owner = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Owner of the rotated log file.";
          example = "root";
        };
        group = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Group of the rotated log file.";
          example = "admin";
        };
        mode = lib.mkOption {
          type = lib.types.strMatching "[0-7]{3,4}";
          default = "644";
          description = "File mode in octal notation.";
          example = "640";
        };
        count = lib.mkOption {
          type = lib.types.ints.unsigned;
          default = 5;
          description = "Number of rotated log files to keep.";
          example = 7;
        };
        size = lib.mkOption {
          type = lib.types.either (lib.types.enum [ "*" ]) lib.types.ints.positive;
          default = "*";
          description = ''
            Size threshold in KB for rotation.
            Use "*" to ignore size and rotate based on time only.
          '';
          example = 1000;
        };
        when = lib.mkOption {
          type = lib.types.str;
          default = "*";
          description = ''
            When to rotate. Examples:
            - "*": Only based on size
            - "$D0": Daily at midnight
            - "$D23": Daily at 23:00
            - "$W0": Weekly on Sunday
            - "$W5": Weekly on Friday
            - "$M1": Monthly on 1st
            - "$ML": Monthly on last day
            - "@T00": ISO format, daily at midnight
          '';
          example = "$D0";
        };
        flags = lib.mkOption {
          type = flagsType;
          default = [ ];
          description = ''
            Rotation flags:
            - B: Binary file, do not add status messages
            - C: Create log file if it does not exist
            - D: Set UF_NODUMP flag on rotated files
            - G: Treat logfile path as a shell glob pattern
            - J: Compress rotated log with bzip2
            - N: Do not signal any process after rotation
            - Z: Compress rotated log with gzip
          '';
          example = [
            "J"
            "N"
          ];
        };
        pidFile = lib.mkOption {
          type = lib.types.nullOr lib.types.path;
          default = null;
          description = "Path to PID file of process to signal after rotation.";
          example = "/var/run/nginx.pid";
        };
        signal = lib.mkOption {
          type = lib.types.nullOr lib.types.ints.positive;
          default = null;
          description = "Signal number to send to the process. Default is SIGHUP (1).";
          example = 1;
        };
      };
    }
  );
in
{
  options.my.services.newsyslog = {
    enable = lib.mkEnableOption "newsyslog log rotation configuration";

    settings = lib.mkOption {
      type = lib.types.attrsOf entryModule;
      default = { };
      description = "Newsyslog log rotation entries.";
      example = lib.literalExpression ''
        {
          "/var/log/myapp.log" = {
            owner = "myuser";
            group = "staff";
            mode = "640";
            count = 7;
            when = "$D0";
            flags = [ "N" "Z" ];
          };
        }
      '';
    };
  };

  config = lib.mkIf cfg.enable {
    assertions = lib.flatten (
      lib.mapAttrsToList (name: entry: [
        {
          assertion = !(lib.elem "J" entry.flags && lib.elem "Z" entry.flags);
          message = "newsyslog entry '${name}': cannot use both J (bzip2) and Z (gzip) compression";
        }
        {
          assertion = entry.signal == null || entry.pidFile != null;
          message = "newsyslog entry '${name}': signal requires pidFile to be set";
        }
      ]) cfg.settings
    );

    environment.etc."newsyslog.d/nix-darwin.conf" = {
      text = configText;
    };
  };
}
